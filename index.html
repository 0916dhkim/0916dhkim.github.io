<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Danny&#x27;s Blog</title><meta name="description" content="Generated by create next app"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/03d35271bd00a657.css" as="style"/><link rel="stylesheet" href="/_next/static/css/03d35271bd00a657.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-2857981f9c69a8b1.js" defer=""></script><script src="/_next/static/chunks/framework-0f8b31729833af61.js" defer=""></script><script src="/_next/static/chunks/main-3ff41d7419af9144.js" defer=""></script><script src="/_next/static/chunks/pages/_app-99c9d8d1f98a807b.js" defer=""></script><script src="/_next/static/chunks/pages/index-f68bf6bf475b4058.js" defer=""></script><script src="/_next/static/4oBCUBd4L8VslUCDipxqf/_buildManifest.js" defer=""></script><script src="/_next/static/4oBCUBd4L8VslUCDipxqf/_ssgManifest.js" defer=""></script><script src="/_next/static/4oBCUBd4L8VslUCDipxqf/_middlewareManifest.js" defer=""></script><style id="server-side-styles">.header-0-2-2 {
  gap: 0.5rem;
  display: flex;
  align-items: center;
  flex-direction: column;
  justify-content: center;
}
.navbar-0-2-3 {
  gap: 2em;
  display: flex;
  flex-direction: row;
  justify-content: center;
}
.navlink-0-2-4 {
  text-decoration: underline;
}
.container-0-2-1 {
  gap: 1rem;
  display: flex;
  padding: 3rem;
  min-height: 100vh;
  flex-direction: column;
  background-color: #F5F5F5;
}
.container-0-2-5 {
  gap: 1.5rem;
  display: flex;
  flex-direction: column;
}
.item-0-2-6 {
  gap: 0.5rem;
  display: flex;
  padding: 1rem;
  box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 12px;
  align-items: start;
  flex-direction: column;
  background-color: white;
}
.summary-0-2-7 {
  flex: 1;
  display: -webkit-box;
  overflow: hidden;
  box-orient: vertical;
  line-clamp: 3;
  text-overflow: ellipses;
}
.date-0-2-8 {
  font-size: 0.875rem;
  align-self: end;
}</style></head><body><div id="__next"><div class="container-0-2-1"><header class="header-0-2-2"><h1>Danny&#x27;s Blog</h1><nav class="navbar-0-2-3"><a class="navlink-0-2-4" href="/">Archive</a><a class="navlink-0-2-4" href="/tags">Tags</a><a class="navlink-0-2-4" href="/lang">Language</a></nav></header><hr/><div class="container-0-2-5"><div class="item-0-2-6"><a href="articles/20211030-hello-world"><h3>Hello World!</h3></a><p class="summary-0-2-7">The first article.</p><span class="date-0-2-8">2021-10-30</span></div><div class="item-0-2-6"><a href="articles/20211030-intro"><h3>Intro</h3></a><p class="summary-0-2-7">The second article.</p><span class="date-0-2-8">2021-10-30</span></div><div class="item-0-2-6"><a href="articles/20211102-fullstack-kr"><h3>웹 개발을 시작하는 분들에게</h3></a><p class="summary-0-2-7">웹 개발을 처음 시작하면 정말 모르는 것 투성이입니다. 웹 서비스가 전반적으로 어떤 구조로 이루어져 있는지 파악하고 나면 모르는 부분이 어디인지 스스로 확인할 수 있고, 따라서 어떤 방향으로 공부해 나가야 할 지 훨씬 명확하게 볼 수 있습니다.</p><span class="date-0-2-8">2021-11-02</span></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"appInfo":{"favicon":"/favicon.ico"},"metadataList":[{"title":"Hello World!","date":"2021-10-30","tags":["hello"],"summary":"The first article.","content":"\n# Hello World\n\nHi there!\n","slug":"20211030-hello-world"},{"title":"Intro","date":"2021-10-30","tags":["hello"],"summary":"The second article.","content":"\n# Intro\n\nHow are you doing?\n","slug":"20211030-intro"},{"title":"웹 개발을 시작하는 분들에게","date":"2021-11-02","tags":["web","fullstack"],"summary":"웹 개발을 처음 시작하면 정말 모르는 것 투성이입니다. 웹 서비스가 전반적으로 어떤 구조로 이루어져 있는지 파악하고 나면 모르는 부분이 어디인지 스스로 확인할 수 있고, 따라서 어떤 방향으로 공부해 나가야 할 지 훨씬 명확하게 볼 수 있습니다.","content":"\n# 웹 개발을 시작하는 분들에게\n\n웹 개발을 처음 시작하면 정말 모르는 것 투성이입니다. 강의를 보면서 따라해보면\n결국 마지막에 뭔가 나오긴 나오지만 \"이게 도대체 왜 되는걸까\" 라는 생각을 지울수가 없죠.\n서적을 보든 튜토리얼을 보든 결국 궁금증은 해소되지 않습니다.\n\"좋아 완벽히 이해했어\" 란 느낌을 받기 위해 책을 두세번씩 다시 읽고\n강사의 설명을 다시 돌려봐도 결국 모르는게 남아있습니다.\n\n웹 서비스가 전반적으로 어떤 구조로 이루어져 있는지 파악하고 나면\n모르는 부분이 어디인지 스스로 확인할 수 있고,\n따라서 어떤 방향으로 공부해 나가야 할 지 훨씬 명확하게 볼 수 있습니다.\n\n## 웹 서비스 조감도\n\n웹 서비스는 3티어 아키텍처라고 불리는 구조로 만들어집니다.\n\n1. 프론트엔드 - Presentation Tier, 브라우저\n\n   웹 서비스의 프론트엔드는 브라우저입니다. HTML, CSS, JS 파일을 서버에서 받아온 후\n   화면에 그려주고, 유저 입력을 받는 역할을 합니다.\n\n2. 백엔드 - Logic Tier, 서버\n\n   Logic tier라는 이름에서 알 수 있듯이 서비스의 로직을 담당하는 곳입니다.\n   브라우저와 데이터베이스 사이에서 데이터의 흐름을 관리하는 역할을 합니다.\n   유저가 데이터베이스 안에 있는 정보를 읽으려면 먼저 백엔드에게 정보를 요청하고,\n   백엔드 서버가 받은 요청을 분석해서 알맞는 정보를 브라우저에게 전달해줍니다.\n   데이터베이스에 정보를 저장할 때도 마찬가지로 백엔드를 통해서만 합니다.\n\n3. 데이터베이스 - Data Tier\n\n   서비스에 필요한 정보가 저장되는 곳입니다. 아이디, 비밀번호 해시, 이메일과 같은\n   유저 정보는 물론이고 상품 정보, 회계 정보 등 대부분의 정보는 데이터베이스에 저장합니다.\n   예외적으로 이미지/비디오 등의 큰 파일들은 파일시스템이나 클라우드 스토리지를 이용하게됩니다.\n\n## 프론트엔드 백엔드 데이터베이스는 서로 어떻게 연결되어 있나요?\n\n- 프론트엔드는 백엔드하고만 통신합니다.\n- 데이터베이스도 백엔드하고만 통신합니다.\n\n[프론트엔드] \u003c-\u003e [백엔드] \u003c-\u003e [데이터베이스]\n\n이렇게 일자로 연결되어 있습니다.\n\n### 프론트엔드와 백엔드의 통신\n\n백엔드 서버는 항상 프론트엔드로 부터 요청(request)이 오기를 기다리고 있습니다.\n그리고 요청을 받으면 응답(response)을 합니다.\n\n웹 프론트엔드와 백엔드 통신의 표준 규격은 HTTP라고 불리고,\nHTTP 요청은 대략 다음과 같이 생겼습니다:\n\n\u003e GET http://example.com/blog/my-post.html\n\n\u003e POST http://example.net/login '{\"email\": \"user@gmail.com\", \"password\": \"supersecure123\"}'\n\n이런 요청을 받으면 서버가 `my-post.html` 파일을 보내주거나 로그인에 성공했다는\n인증을 보내주는 식으로 통신이 이루어 집니다.\n\n### 백엔드와 데이터베이스의 통신\n\n프론트-백엔드 통신이 HTTP 규격으로 통일된 것에 반해\n데이터베이스는 데이터베이스별로 통신규격이 다릅니다.\n또한, 각 응답이 끝나면 연결이 끊어지는 HTTP와 달리 일반적인 데이터베이스 통신은\n상시로 연결되어 있게 설정되어 있습니다.\n\n## 코드 예제\n\n웹 서비스의 각 구성요소가 어떤 역할을 하는지 직접 코드를 보면서 살펴봅시다.\n\n### 프론트엔드\n\n프론트엔드 코딩은 다음과 같은 내용을 다룹니다:\n\n- 유저 상호작용에 어떻게 반응해야 하는지 코딩.\n- 프론트에 필요한 내용을 백엔드로 요청, 혹은 백엔드가 필요한 정보를 유저에게 받아서 전달.\n- 상황에 맞게 화면 내용 수정.\n\n```html\n\u003cscript\u003e\n  async function myFunction() {\n    // 백엔드에 정보를 요청\n    const response = await fetch(\"http://example.com/userlist\");\n    const userlist = await response.json();\n\n    // 응답받은 내용을 화면에 표시\n    document.getElementById(\"userlist\").innerHTML = userlist;\n  }\n\u003c/script\u003e\n\n\u003c!-- 버튼으로 유저 입력 받기 --\u003e\n\u003cbutton onclick=\"myFunction()\"\u003e정보 가져오기\u003c/button\u003e\n```\n\n### 백엔드\n\n백엔드 코딩은 주로 프론트엔드로부터 들어오는 요청을 어떻게 처리할지에 대한 내용입니다.\n\n```py\n# GET /userlist 요청이 들어오면 이 함수로 응답\n@app.route(\"/userlist\", methods=[\"GET\"])\ndef get_userlist():\n  # 데이터베이스에서 유저 리스트 읽기\n  users = User.get_all()\n\n  # 요청받은 유저 데이터를 전달\n  return {\"users\": users}\n```\n\n### 데이터베이스\n\nMySQL, PostgreSQL, MongoDB, Firestore 등의 데이터베이스가 많이 쓰이며,\n실질적인 코딩보다는 데이터베이스를 설정하는 데에 더 신경을 많이 씁니다.\n\n## 헷갈리는 변형들\n\n많은 경우 프론트엔드 코드와 백엔드 코드는 완전히 분리해서 작성하지만,\n때때로 튜토리얼이나 서적을 읽다보면 프로젝트 구조가 앞서 얘기한 것처럼 3단계로 깔끔하게\n분리되어 있지 않은 경우가 있습니다.\n서비스 자체는 3단계로 잘 나눠져 있지만 코드가 섞여있어서 입문자 입장에서는 충분히 헷갈릴 수 있습니다.\n\n- 템플릿 엔진\n\n  요즘은 점차 줄어드는 추세지만 백엔드에 (템플릿이라고 부르는) HTML 문서의 틀를 만들어 뒀다가, 유저 요청이 오면\n  템플릿에 데이터를 채워넣고 HTML 문서를 생성해서 보내주는 방식이 많이 쓰였습니다.\n  이 경우 HTML/CSS/JS 등의 파일들이 백엔드 코드의 일부가 되기 때문에 잘 모르는 사람이 보면 어디까지가 백엔드 코드이고\n  어디까지가 프론트엔드 코드인지 구별하기 어렵습니다.\n\n- 프론트엔드 서버? 프론트엔드 빌드?\n\n  브라우저에서 사용하는 HTML/CSS/JS를 다루는게 프론트엔드 개발입니다. 그런데 브라우저도 HTML/CSS/JS 파일들을\n  어딘가에서 받아와야 하죠. 백엔드가 브라우저에게 필요한 HTML/CSS/JS 파일을 제공하는 역할을 담당할 수도 있지만,\n  파일 배포를 전담하는 서버를 따로 분리하는 경우가 많습니다. 이 파일 배포 전담 서버를 \"프론트 서버\"라고 부르는데\n  처음 들으면 굉장히 헷갈리는 이름입니다.\n\n  게다가 여러 라이브러리를 사용하고 후처리가 필요한 JS 코드의 경우 \"빌드\"라는 과정을 거치는 경우가 흔합니다.\n  복잡한 프로젝트를 Webpack, Babel, Browserify 등의 도구를 사용해서 브라우저가 사용할 수 있는 JS로\n  만들어주는 과정인데요, 브라우저에는 빌드된 JS파일만 제공되기 때문에\n  브라우저에서 실행되는 JS파일과 개발자가 작성한 (소스코드라고 부르는) JS파일은 다른 파일입니다.\n  최근 프론트엔드 프레임워크들은 거의 100% 복잡한 빌드과정이 필요하기 때문에\n  입문자들은 본인이 쓴 코드가 어떤 과정을 거쳐서 유저에게 전달되는지 이해하기 어렵습니다.\n\n- SSR/CSR/SSG\n\n  여기까지만 해도 헷갈리지만, 엎친데 덮친 격으로 프론트엔드 개발에 일종의 복고 열풍이 불고 있습니다.\n\n  - SSR: Server-side rendering의 약자로, 서버에서 HTML을 생성해서 브라우저에 전달하는 방식을 뜻합니다.\n    앞서 템플릿 엔진을 설명드렸는데, 거기서 나아간 기술이라고 생각하시면 됩니다.\n    템플릿 엔진과 다른 점은 HTML 틀이 아닌 기존의 프론트엔드 프레임워크를 활용해서 문서를 생성한다는 점입니다.\n    템플릿 엔진과 마찬가지로 백엔드 코드와 프론트엔드 코드가 섞이기 때문에 입문자는 명확히 경계를 구별하지 못합니다.\n  - CSR: Client-side rendering의 약자로, SSR의 반대 개념입니다.\n    기존 프레임워크들이 사용하는 방식으로, SSR과 구별하기 위해서 생긴 단어입니다.\n  - SSG: Static site generation의 약자입니다. 프로그래밍으로 HTML/CSS/JS 파일을 생성하는 기술을 뜻하며,\n    백엔드가 필요없는 프로젝트에 사용합니다.\n    SSR과 마찬가지로 기존 프론트엔드 프레임워크를 활용한 SSG 기술들이 있습니다.\n\n## 아직 헷갈린다면...\n\n정상입니다. 하지만 중요한건 여기서부터입니다. 모르는 부분을 스스로 짚어나갈수 있기 때문이죠!\n프론트엔드, 백엔드, 데이터베이스 사이의 정보의 흐름을 차례대로 확인하고,\n정보가 어디로 흘러가는지 알 수 없는 부분을 찾으면 됩니다.\n\n- 예시: \"이메일과 비밀번호를 입력하고 로그인 버튼을 누르면 비공개 페이지로 넘어가는데, 어떤 원리일까?\"\n  - 로그인 버튼을 누르면 백엔드로 POST 요청이 간다는건 알고 있어.\n  - POST /login 경로의 컨트롤러가 실행되겠지.\n  - 그리고 어떻게 되는거지? \u003c- 이 내용을 검색/질문\n\n보시다시피 \"로그인 기능은 어떻게 동작하나요?\"보다는 \"이 코드에서 리턴 값은 어디로 가나요?\"가\n훨씬 구체적이고 대답하기 쉬운 질문입니다.\n\n## 마치며\n\n처음 시작할 때는 아는 것과 모르는 것의 경계가 보이지 않기 때문에 쉽게 헤메게 되지만,\n시간이 지날수록 모르는 영역이 어디인지 훨씬 잘 보이게 됩니다.\n이 글이 모르는 부분을 빠르게 판별하는데 도움이 되었으면 좋겠습니다.\n","slug":"20211102-fullstack-kr"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"4oBCUBd4L8VslUCDipxqf","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>