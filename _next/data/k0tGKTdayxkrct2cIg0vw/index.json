{"pageProps":{"posts":[{"id":"ckxy9drh7000009ldqax7z78v","title":"웹 개발을 시작하는 분들에게","language":"KR","summary":"웹 개발을 처음 시작하면 정말 모르는 것 투성이입니다. 웹 서비스가 전반적으로 어떤 구조로 이루어져 있는지 파악하고 나면 모르는 부분이 어디인지 스스로 확인할 수 있고, 따라서 어떤 방향으로 공부해 나가야 할 지 훨씬 명확하게 볼 수 있습니다.","content":"웹 개발을 처음 시작하면 정말 모르는 것 투성이입니다. 강의를 보면서 따라해보면\n결국 마지막에 뭔가 나오긴 나오지만 \"이게 도대체 왜 되는걸까\" 라는 생각을 지울수가 없죠.\n서적을 보든 튜토리얼을 보든 결국 궁금증은 해소되지 않습니다.\n\"좋아 완벽히 이해했어\" 란 느낌을 받기 위해 책을 두세번씩 다시 읽고\n강사의 설명을 다시 돌려봐도 결국 모르는게 남아있습니다.\n\n웹 서비스가 전반적으로 어떤 구조로 이루어져 있는지 파악하고 나면\n모르는 부분이 어디인지 스스로 확인할 수 있고,\n따라서 어떤 방향으로 공부해 나가야 할 지 훨씬 명확하게 볼 수 있습니다.\n\n## 웹 서비스 조감도\n\n웹 서비스는 3티어 아키텍처라고 불리는 구조로 만들어집니다.\n\n1. 프론트엔드 - Presentation Tier, 브라우저\n\n   웹 서비스의 프론트엔드는 브라우저입니다. HTML, CSS, JS 파일을 서버에서 받아온 후\n   화면에 그려주고, 유저 입력을 받는 역할을 합니다.\n\n2. 백엔드 - Logic Tier, 서버\n\n   Logic tier라는 이름에서 알 수 있듯이 서비스의 로직을 담당하는 곳입니다.\n   브라우저와 데이터베이스 사이에서 데이터의 흐름을 관리하는 역할을 합니다.\n   유저가 데이터베이스 안에 있는 정보를 읽으려면 먼저 백엔드에게 정보를 요청하고,\n   백엔드 서버가 받은 요청을 분석해서 알맞는 정보를 브라우저에게 전달해줍니다.\n   데이터베이스에 정보를 저장할 때도 마찬가지로 백엔드를 통해서만 합니다.\n\n3. 데이터베이스 - Data Tier\n\n   서비스에 필요한 정보가 저장되는 곳입니다. 아이디, 비밀번호 해시, 이메일과 같은\n   유저 정보는 물론이고 상품 정보, 회계 정보 등 대부분의 정보는 데이터베이스에 저장합니다.\n   예외적으로 이미지/비디오 등의 큰 파일들은 파일시스템이나 클라우드 스토리지를 이용하게됩니다.\n\n## 프론트엔드 백엔드 데이터베이스는 서로 어떻게 연결되어 있나요?\n\n- 프론트엔드는 백엔드하고만 통신합니다.\n- 데이터베이스도 백엔드하고만 통신합니다.\n\n[프론트엔드] <-> [백엔드] <-> [데이터베이스]\n\n이렇게 일자로 연결되어 있습니다.\n\n### 프론트엔드와 백엔드의 통신\n\n백엔드 서버는 항상 프론트엔드로 부터 요청(request)이 오기를 기다리고 있습니다.\n그리고 요청을 받으면 응답(response)을 합니다.\n\n웹 프론트엔드와 백엔드 통신의 표준 규격은 HTTP라고 불리고,\nHTTP 요청은 대략 다음과 같이 생겼습니다:\n\n> GET http://example.com/blog/my-post.html\n\n> POST http://example.net/login '{\"email\": \"user@gmail.com\", \"password\": \"supersecure123\"}'\n\n이런 요청을 받으면 서버가 `my-post.html` 파일을 보내주거나 로그인에 성공했다는\n인증을 보내주는 식으로 통신이 이루어 집니다.\n\n### 백엔드와 데이터베이스의 통신\n\n프론트-백엔드 통신이 HTTP 규격으로 통일된 것에 반해\n데이터베이스는 데이터베이스별로 통신규격이 다릅니다.\n또한, 각 응답이 끝나면 연결이 끊어지는 HTTP와 달리 일반적인 데이터베이스 통신은\n상시로 연결되어 있게 설정되어 있습니다.\n\n## 코드 예제\n\n웹 서비스의 각 구성요소가 어떤 역할을 하는지 직접 코드를 보면서 살펴봅시다.\n\n### 프론트엔드\n\n프론트엔드 코딩은 다음과 같은 내용을 다룹니다:\n\n- 유저 상호작용에 어떻게 반응해야 하는지 코딩.\n- 프론트에 필요한 내용을 백엔드로 요청, 혹은 백엔드가 필요한 정보를 유저에게 받아서 전달.\n- 상황에 맞게 화면 내용 수정.\n\n```html\n<script>\n  async function myFunction() {\n    // 백엔드에 정보를 요청\n    const response = await fetch(\"http://example.com/userlist\");\n    const userlist = await response.json();\n\n    // 응답받은 내용을 화면에 표시\n    document.getElementById(\"userlist\").innerHTML = userlist;\n  }\n</script>\n\n<!-- 버튼으로 유저 입력 받기 -->\n<button onclick=\"myFunction()\">정보 가져오기</button>\n```\n\n### 백엔드\n\n백엔드 코딩은 주로 프론트엔드로부터 들어오는 요청을 어떻게 처리할지에 대한 내용입니다.\n\n```py\n# GET /userlist 요청이 들어오면 이 함수로 응답\n@app.route(\"/userlist\", methods=[\"GET\"])\ndef get_userlist():\n  # 데이터베이스에서 유저 리스트 읽기\n  users = User.get_all()\n\n  # 요청받은 유저 데이터를 전달\n  return {\"users\": users}\n```\n\n### 데이터베이스\n\nMySQL, PostgreSQL, MongoDB, Firestore 등의 데이터베이스가 많이 쓰이며,\n실질적인 코딩보다는 데이터베이스를 설정하는 데에 더 신경을 많이 씁니다.\n\n## 헷갈리는 변형들\n\n많은 경우 프론트엔드 코드와 백엔드 코드는 완전히 분리해서 작성하지만,\n때때로 튜토리얼이나 서적을 읽다보면 프로젝트 구조가 앞서 얘기한 것처럼 3단계로 깔끔하게\n분리되어 있지 않은 경우가 있습니다.\n서비스 자체는 3단계로 잘 나눠져 있지만 코드가 섞여있어서 입문자 입장에서는 충분히 헷갈릴 수 있습니다.\n\n- 템플릿 엔진\n\n  요즘은 점차 줄어드는 추세지만 백엔드에 (템플릿이라고 부르는) HTML 문서의 틀를 만들어 뒀다가, 유저 요청이 오면\n  템플릿에 데이터를 채워넣고 HTML 문서를 생성해서 보내주는 방식이 많이 쓰였습니다.\n  이 경우 HTML/CSS/JS 등의 파일들이 백엔드 코드의 일부가 되기 때문에 잘 모르는 사람이 보면 어디까지가 백엔드 코드이고\n  어디까지가 프론트엔드 코드인지 구별하기 어렵습니다.\n\n- 프론트엔드 서버? 프론트엔드 빌드?\n\n  브라우저에서 사용하는 HTML/CSS/JS를 다루는게 프론트엔드 개발입니다. 그런데 브라우저도 HTML/CSS/JS 파일들을\n  어딘가에서 받아와야 하죠. 백엔드가 브라우저에게 필요한 HTML/CSS/JS 파일을 제공하는 역할을 담당할 수도 있지만,\n  파일 배포를 전담하는 서버를 따로 분리하는 경우가 많습니다. 이 파일 배포 전담 서버를 \"프론트 서버\"라고 부르는데\n  처음 들으면 굉장히 헷갈리는 이름입니다.\n\n  게다가 여러 라이브러리를 사용하고 후처리가 필요한 JS 코드의 경우 \"빌드\"라는 과정을 거치는 경우가 흔합니다.\n  복잡한 프로젝트를 Webpack, Babel, Browserify 등의 도구를 사용해서 브라우저가 사용할 수 있는 JS로\n  만들어주는 과정인데요, 브라우저에는 빌드된 JS파일만 제공되기 때문에\n  브라우저에서 실행되는 JS파일과 개발자가 작성한 (소스코드라고 부르는) JS파일은 다른 파일입니다.\n  최근 프론트엔드 프레임워크들은 거의 100% 복잡한 빌드과정이 필요하기 때문에\n  입문자들은 본인이 쓴 코드가 어떤 과정을 거쳐서 유저에게 전달되는지 이해하기 어렵습니다.\n\n- SSR/CSR/SSG\n\n  여기까지만 해도 헷갈리지만, 엎친데 덮친 격으로 프론트엔드 개발에 일종의 복고 열풍이 불고 있습니다.\n\n  - SSR: Server-side rendering의 약자로, 서버에서 HTML을 생성해서 브라우저에 전달하는 방식을 뜻합니다.\n    앞서 템플릿 엔진을 설명드렸는데, 거기서 나아간 기술이라고 생각하시면 됩니다.\n    템플릿 엔진과 다른 점은 HTML 틀이 아닌 기존의 프론트엔드 프레임워크를 활용해서 문서를 생성한다는 점입니다.\n    템플릿 엔진과 마찬가지로 백엔드 코드와 프론트엔드 코드가 섞이기 때문에 입문자는 명확히 경계를 구별하지 못합니다.\n  - CSR: Client-side rendering의 약자로, SSR의 반대 개념입니다.\n    기존 프레임워크들이 사용하는 방식으로, SSR과 구별하기 위해서 생긴 단어입니다.\n  - SSG: Static site generation의 약자입니다. 프로그래밍으로 HTML/CSS/JS 파일을 생성하는 기술을 뜻하며,\n    백엔드가 필요없는 프로젝트에 사용합니다.\n    SSR과 마찬가지로 기존 프론트엔드 프레임워크를 활용한 SSG 기술들이 있습니다.\n\n## 아직 헷갈린다면...\n\n정상입니다. 하지만 중요한건 여기서부터입니다. 모르는 부분을 스스로 짚어나갈수 있기 때문이죠!\n프론트엔드, 백엔드, 데이터베이스 사이의 정보의 흐름을 차례대로 확인하고,\n정보가 어디로 흘러가는지 알 수 없는 부분을 찾으면 됩니다.\n\n- 예시: \"이메일과 비밀번호를 입력하고 로그인 버튼을 누르면 비공개 페이지로 넘어가는데, 어떤 원리일까?\"\n  - 로그인 버튼을 누르면 백엔드로 POST 요청이 간다는건 알고 있어.\n  - POST /login 경로의 컨트롤러가 실행되겠지.\n  - 그리고 어떻게 되는거지? <- 이 내용을 검색/질문\n\n보시다시피 \"로그인 기능은 어떻게 동작하나요?\"보다는 \"이 코드에서 리턴 값은 어디로 가나요?\"가\n훨씬 구체적이고 대답하기 쉬운 질문입니다.\n\n## 마치며\n\n처음 시작할 때는 아는 것과 모르는 것의 경계가 보이지 않기 때문에 쉽게 헤메게 되지만,\n시간이 지날수록 모르는 영역이 어디인지 훨씬 잘 보이게 됩니다.\n이 글이 모르는 부분을 빠르게 판별하는데 도움이 되었으면 좋겠습니다.","createdAt":"2022-01-03T05:45:07.676Z","updatedAt":"2022-01-03T05:45:07.679Z"},{"id":"ckyjl0ypl723309larum2rj0o","title":"모노리포에서 Prisma 사용하기","language":"EN","summary":null,"content":"프리즈마는 차원이 다른 개발자 경험을 제공하는 타입스크립트 ORM입니다. 대부분의 경우 프리즈마는 설정이 필요 없지만, 모노리포에 프리즈마를 추가하는 작업은 직관적이지 않을 수 있습니다.\n이 포스트에서는 프리즈마를 모노리포 환경에서 사용하는 법을 다룹니다.\n\n# 간단한 프리즈마 소개\n프리즈마에는 크게 두가지 중요한 개념이 있습니다. [스키마](https://www.prisma.io/docs/concepts/components/prisma-schema) 그리고 [클라이언트](https://www.prisma.io/docs/concepts/components/prisma-client)인데요:\n- 프리즈마 스키마는 데이터 모델과 데이터베이스 설정을 정의하는 텍스트 파일이며, 이렇게 생겼습니다:\n  ```\n  datasource db {\n    url      = env(\"DATABASE_URL\")\n    provider = \"postgresql\"\n  }\n\n  generator client {\n    provider = \"prisma-client-js\"\n  }\n\n  model Contact {\n    id        Int      @id @default(autoincrement())\n    createdAt DateTime @default(now())\n    email     String   @unique\n    name      String?\n  }\n  ```\n- 이 스키마를 이용해서 프리즈마는 `@prisma/client` 라는 패키지를 생성하는데, 이 패키지가 ORM의 타입지원과 기능을 제공합니다:\n  ```\n  import {PrismaClient} from '@prisma/client';\n  const prisma = new PrismaClient();\n\n  // 자동으로 `Contact` 타입으로 유추됩니다.\n  const newContact = await prisma.contact.create({\n    data: {email: 'john@example.com'},\n  });\n  ```\n\n# 그렇다면 여러 패키지에서 하나의 `@prisma/client`를 돌려 쓰려면 어떻게 해야 하나요?\n모노리포 워크스페이스 구조가 이런 식으로 생겼다고 해봅시다:\n- Project Root\n  - apps\n    - dashboard\n  - libs\n    - core\n\n생성된 프리즈마 클라이언트를 공유하려면 일단 프리즈마 스키마를 별도의 패키지에 이렇게 집어넣습니다:\n- Project Root\n  - apps\n    - dashboard\n  - libs\n    - core\n    - shared-prisma\n      - prisma\n        - schema.prisma\n      - src\n        - index.ts\n\n이제 `prisma generate` 커맨드를 사용해서 `@prisma/client`를 생성하고, 그 생성된 클라이언트를 `libs/shared-prisma/src/index.ts` 모듈에서 re-export 해주면 됩니다:\n```ts\nexport * from '@prisma/client';\n\n// 선택사항: 프리즈마 인스턴스를 여기에서 생성할 수도 있습니다.\nimport {PrismaClient} from '@prisma/client';\nexport const prisma = new PrismaClient();\n```\n\n이렇게 설정해두면 다른 패키지에서 공유된 프리즈마 클라이언트를 import 할 수 있습니다.\n```ts\nimport {prisma} from '@myscope/shared-prisma';\n\nconst contacts = await prisma.contact.findMany();\n```\n\n# Nx 사용시 주의사항\n[buildable 혹은 publishable](https://nx.dev/structure/buildable-and-publishable-libraries) 라이브러리를 사용하지 않는다면, 모든 의존성이 워크스페이스에 설치됩니다.\n상황에 따라 이게 편할 수도 있지만 정말 불편할 수도 있습니다.\n- 좋은 경우: `@prisma/client`가 워크스페이스에 설치되기 때문에 별도로 `shared-prisma`에서 re-export를 할 필요가 없습니다. 모든 패키지에서 이미 `@prisma/client`에 접근 가능합니다.\n- 안좋은 경우: 모노리포 안에 서로 다른 프리즈마 스키마를 (따라서 다른 프리즈마 클라이언트를) 사용하는 앱이 여러개 있는 경우, Nx의 이러한 구조가 골치아픕니다.\n  각각의 프리즈마 스키마에서 `@prisma/client`를 생성할 때마다 전부 워크스페이스의 `@prisma/client`를 덮어쓰기 때문입니다.\n  이 문제를 해결하기 위해서는 `shared-prisma`를 독립적인 `package.json`과 `node_modules`를 가진 buildable Nx 라이브러리로 만들어줘야합니다.","createdAt":"2022-01-18T03:54:15.609Z","updatedAt":"2022-01-18T04:15:53.051Z"},{"id":"ckyjil4zl462609md50rnog8c","title":"Using Prisma in a Monorepo","language":"EN","summary":null,"content":"Prisma is an amazing ORM for TypeScript that allows you to access database in a completely type-safe way.\nThe developer experience Prisma provides can't be compared to anything else. In this article, you will learn how to use Prisma in a monorepo.\n\n# Brief Overview of How Prisma Works\nThere are two major concept in Prisma: [schema](https://www.prisma.io/docs/concepts/components/prisma-schema) and [client](https://www.prisma.io/docs/concepts/components/prisma-client)\n- Prisma schema is a text file describing the data models and database configurations. It looks like this:\n  ```\n  datasource db {\n    url      = env(\"DATABASE_URL\")\n    provider = \"postgresql\"\n  }\n\n  generator client {\n    provider = \"prisma-client-js\"\n  }\n\n  model Contact {\n    id        Int      @id @default(autoincrement())\n    createdAt DateTime @default(now())\n    email     String   @unique\n    name      String?\n  }\n  ```\n- From schema, Prisma generates a package called `@prisma/client` which provides type-safe interface to your models.\n  ```\n  import {PrismaClient} from '@prisma/client';\n  const prisma = new PrismaClient();\n\n  // This is inferred as `Contact` type.\n  const newContact = await prisma.contact.create({\n    data: {email: 'john@example.com'},\n  });\n  ```\n\n# Great! How Do I Share the Generated `@prisma/client` across Multiple Packages?\nLet's say you have a monorepo workspace that is structured like this:\n- Project Root\n  - apps\n    - dashboard\n  - libs\n    - core\n\nIf you want to share the generated Prisma client, you can put your Prisma schema in a separate package like this:\n- Project Root\n  - apps\n    - dashboard\n  - libs\n    - core\n    - shared-prisma\n      - prisma\n        - schema.prisma\n      - src\n        - index.ts\n\nAfter generating `@prisma/client` with `prisma generate` command, re-export the generated client from `libs/shared-prisma/src/index.ts` module:\n```ts\nexport * from '@prisma/client';\n\n// Optional: Create a Prisma client instance here.\nimport {PrismaClient} from '@prisma/client';\nexport const prisma = new PrismaClient();\n```\n\nNow you can import shared Prisma client from other packages:\n```ts\nimport {prisma} from '@myscope/shared-prisma';\n\nconst contacts = await prisma.contact.findMany();\n```\n\n# Caveats for Nx\nUnless you are using a [buildable or publishable](https://nx.dev/structure/buildable-and-publishable-libraries) library,\nall dependencies are installed to the workspace. This can be both good and bad depends on your needs:\n- Good: you don't need to re-export `@prisma/client` from `shared-prisma` because `@prisma/client` is installed to the workspace. All packages can access it already.\n- Bad: if you want to create multiple apps that has different Prisma schemas (thus different Prisma clients), Nx's structure is not so great.\n  When you try to generate `@prisma/client` using different Prisma schemas, they all get installed to the central `@prisma/client` overwriting each other.\n  To solve this you need to make `shared-prisma` a buildable Nx library with its own `package.json` and `node_modules`.","createdAt":"2022-01-18T02:45:58.017Z","updatedAt":"2022-01-18T04:15:59.834Z"},{"id":"ckzqfz7v648780ak1368tem43","title":"프리즈마 스키마에서 CMS를 생성할 수 있을까?","language":"KR","summary":null,"content":"스키마에 꼭 맞는 타입스크립트 클라이언트를 생성해 주는 것은 프리즈마가 다른 ORM보다 돋보이게 해주는 장점입니다.\n그래서 프리즈마가 제공하는 인터페이스를 사용할 때는 복잡한 쿼리를 작성해도 타입을 걱정하는 일이 거의 없죠.\n놀랍게도 프리즈마의 코드 제너레이터 로직은 확장 가능하게 설계되어서, 프리즈마 클라이언트 이외의 코드도 생성하게 만드는게 가능합니다.\n\n이런 생각의 연장선으로 프리즈마가 CMS를 생성하게 해보자는 시도를 해보았습니다.\n아직 프로젝트는 개념 증명 단계지만, 성공한다면 백오피스나 사내 어드민 페이지로 활용하는게 가능할 것으로 기대됩니다.\n\n# 참고한 프로젝트\n이미 시중에 프리즈마를 활용한 CMS들이 존재하기 때문에, 그 중 눈에 띄는 프로젝트들부터 분석해 보았습니다.\n## KeystoneJS\nKeystoneJS는 ORM이 내장된 headless CMS입니다.\nKeystone schema API로 데이터베이스를 디자인하면 GraphQL 서버와 Admin UI를 전부 생성해주는 굉장한 개발편의성을 자랑합니다.\n2021년에는 프리즈마를 데이터베이스 어댑터로 사용하는걸 지원하면서 다른 headless CMS 경쟁자들과는 차원이 다르다는걸 보여줬습니다.\nKeystone은 이렇게 우수한 프레임워크지만 데이터베이스를 직접 관리하는 이상, 기존에 있던 db에 붙여서 사용하는건 힘들다는 한계가 있었습니다.\n\n## PalJS\n개인 개발자가 시작한 GraphQL API + Admin UI 생성도구입니다.\n풀스택을 한번에 해결해버린다는 점에서 Keystone과 유사하지만, PalJS는 프리즈마 제너레이터라는 점에서 차별점이 있습니다.\n프리즈마 스키마만 있다면 어떤 프로젝트에든 붙여서 쓸 수 있고,\nprisma instrospection과 조합하면 매우 유연하게 적용할 수 있습니다.\n하지만 UI코드가 컴포넌트 단위로 생성되기 때문에 커스텀한 UI를 만드는데에 한계가 있었습니다.\n\n# prisma-generator-proto\n기존 프리즈마 기반 CMS들의 한계점을 극복하기 위해서는 어떻게 설계하는게 좋을지 고민한 결과\n`prisma-generator-proto` 라는 프로토타입 프로젝트를 만들게 되었습니다.\n\n## 프리즈마 제너레이터 사용\nCMS는 그 자체로 하나의 서비스가 되는 경우도 있지만, 다른 서비스의 데이터를 관리하기 위한 목적으로 사용하는 경우가 많습니다.\n그렇다면 이미 존재하는 서비스에 쉽게 붙일 수 있게 설계된 CMS가 범용성에서 우위를 차지할 수 있다고 볼 수 있습니다.\nKeystone처럼 스스로 데이터베이스 스키마와 migration까지 전부 관리하는 도구는 기존 프로젝트에 붙이기 힘들죠.\n`prisma generate` 커맨드에서 생성되는 CMS라면 훨씬 도입하는데 부담이 적을것이라고 판단했습니다.\n\n## UI는 리액트 훅으로 제공\nPalJS와 같이 단번에 admin UI 전체가 생성되는건 확실히 편리하지만, 제품이 성장함에 따라 UI를 커스텀 해야할 필요가 생기는 시점이 옵니다.\nMaterial UI 같은 컴포넌트 라이브러리에서 제공하는 UI를 커스텀 해보려고 시도해보신 분들은 공감하시겠지만\n패키지로 제공되는 컴포넌트를 입맛대로 수정하는건 꽤나 번거로운 일입니다.\n그래서 `prisma-generator-proto`는 UI를 만드는데 필요한 데이터와 기능만 리액트 훅으로 제공해서\nadmin UI 제작이 쉽지만 충분히 유연하도록 만들었습니다.\n\n# 작동원리\n`prisma-generator-proto`를 포함한 프리즈마 제너레이터들은 모두 비슷한 방식으로 작동합니다.\n## 프리즈마 스키마\n시작은 프리즈마의 핵심이라고 할 수 있는 `schema.prisma` 파일부터입니다.\n```\ndatasource db {\n  url      = env(\"DATABASE_URL\")\n  provider = \"postgresql\"\n}\n\ngenerator client {\n  provider = \"prisma-client-js\"\n}\n\nmodel User {\n  id        Int      @id @default(autoincrement())\n  email     String   @unique\n  name      String?\n  posts     Post[]\n}\n\nmodel Post {\n  id        Int      @id @default(autoincrement())\n  title     String   @db.VarChar(255)\n  author    User?    @relation(fields: [authorId], references: [id])\n  authorId  Int?\n}\n```\n\n위의 예시에서 볼 수 있듯이 `schema.prisma` 파일은 세 부분으로 나누어져 있습니다.\n- datasource: 데이터베이스 연결 설정입니다.\n- model: 데이터 모델 정의입니다.\n- generator: 이 스키마를 활용하는 제너레이터를 설정합니다. 기본적으로 `prisma-client-js` 라는 제너레이터를 사용해서 프리즈마 클라이언트를 생성하게 되는데, 추가적으로 다른 제너레이터를 실행하도록 설정할 수 있습니다.\n\n프리즈마 사용자는 스키마를 직접 작성할 수도 있고, prisma introspection을 사용해서 기존 db에서 스키마를 뽑아내는 것도 가능합니다.\n\n## prisma generate\n`prisma generate` 커맨드는 `schema.prisma` 파일에서 설정해준 제너레이터들을 차례로 실행합니다.\n스키마를 파싱하는 작업은 프리즈마가 담당하며, 파싱된 결과물인 DMMF가 각 제너레이터에 전달됩니다.\nDMMF에는 다음과 같은 자료가 JS 객체 형태로 들어있습니다:\n- 모든 모델 리스트\n- 각 모델 안에 들어있는 필드 리스트\n- 각 필드의 타입, 초기값, nullable 유무\n- 모델 사이의 association\n\n또한, 프리즈마는 output 디렉토리가 어디로 설정되어있는지도 제너레이터에 전달해주기 때문에\n제너레이터를 작성하는 개발자는 DMMF를 이용해서 output 디렉토리에 원하는 파일을 쓰기만 하면 됩니다!\n\n# 진행상황\n`prisma-generator-proto`가 현재 생성할 수 있는 코드는 다음과 같습니다.\n## 서버 코드 생성\nCRUD용 route handler들을 생성해서 Express 라우터 형태로 제공하며, 서버 자체는 생성해주지 않습니다.\n\n사용 예시:\n```ts\nimport express from \"express\";\nimport { router } from \"../__generated__\";\n\nconst app = express();\n\napp.use(express.json());\n\n// 제너레이터가 생성한 route handler을 사용.\napp.use(\"/api\", router);\n\napp.listen(3001, () => {\n  console.log(\"Listening...\");\n});\n```\n## 클라이언트 코드 생성\n생성된 API handler를 활용하는 리액트 훅을 제공합니다.\n서버와 마찬가지로 프론트 엔드 프로젝트 자체를 생성해주지는 않습니다.\n\n사용 예시 (모델 이름이 `Country` 인 경우):\n```ts\nimport Form from \"../components/Form\";\nimport React from \"react\";\nimport Table from \"../components/Table\";\nimport styles from \"../styles/DataScreen.module.css\";\nimport { useCountry } from \"../__generated__/hooks\";\n\nconst Countries = () => {\n  // 생성된 훅을 사용해서 CRUD 가능.\n  const [countries, addHandler, formState, setFormState] = useCountry();\n\n  return (\n    <div className={styles.screen}>\n      <Form\n        name=\"Country\"\n        keys={[\"name\", \"population\", \"continentId\", \"isUnMember\"]}\n        onSubmit={addHandler}\n        state={formState}\n        setState={setFormState}\n      />\n\n      <Table\n        name=\"Country\"\n        list={countries}\n        keys={[\"id\", \"name\", \"population\", \"continentId\", \"isUnMember\"]}\n      />\n    </div>\n  );\n};\n\nexport default Countries;\n```\n## NPM 패키지\n[prisma-generator-proto](https://www.npmjs.com/package/@prisma-korea/prisma-generator-proto)는 NPM에서 다운받으실 수 있습니다.\n\n소스코드는 [GitHub 리포](https://github.com/prisma-korea/prisma-generator-proto)에 공개되어 있습니다.\n\n# 다른 아이디어\n저는 CMS를 만들었지만, 다른 사람들이 만든 신기한 제너레이터들도 구경해보고 싶으시다면 이 [리스트도](https://www.prisma.io/docs/concepts/components/prisma-schema/generators#community-generators) 살펴보세요!\n\n프리즈마 코리아 커뮤니티에서도 다양한 시도를 하고 있으니 직접 참여해보고 싶으시다면 카카오톡 오픈채팅에서 문의해주세요.","createdAt":"2022-02-17T03:47:01.650Z","updatedAt":"2022-02-17T04:03:18.694Z"}]},"__N_SSG":true}